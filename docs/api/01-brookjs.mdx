---
name: brookjs
route: /api/brookjs/
order: 1
menu: API
---

# brookjs

## action module

The `action` module provides the action constants and creators that `brookjs` uses internally. These can be used to interact with any of the streams exported by the framework. The `UPPER_SNAKE_CASE` strings are the action type, while the `camelCaseAction` functions are the action creators. All actions generated by the framework comply with the [Flux Standard Action][fsa].

### Api

#### `RAF` & `raf$`

The `raf$` stream emits a `RafAction` on a `requestAnimationFrame` tick. This will schedule renders in sync with the framework rendering flow.

```flow
type RafAction = {
    type: typeof RAF;
    payload: {
        time: DOMHighResTimeStamp;
    };
}
```

## combineActionReducers

`combineActionReducers` is a function that takes an array of tuples and a default state, and returns a Redux reducer function. The reducer tuples should be array with a string, which the `action.type` is matched against, and a reducer function, that takes a `state` and the `action` and returns a new state.

## Parameters

* `{Array<ReducerTuple>} cond` - An array of ReducerTuples, where
    * type `ReducerTuple = [ActionType, ReducerFunction]`
* `{any} defaults` - Default state to return when no type matches.

## helpers module

The helpers module isn't a separate module but a collection of functions to assist with common tasks in `brookjs`.

### `mapActionTo` {Function}

`mapActionTo` is a simple function designed to simplify the process of mapping child events to its parent's events. It modifies the action's `type` and maintains the previous source in the Action's `meta`.

```js
import { mapActionTo } from 'brookjs';

const child = {
    type: 'CHILD',
    payload: { value: true }
};

const parent = mapActionTo('CHILD', 'PARENT', child);

assert.deepEqual(parent, {
    type: 'PARENT',
    payload: { value: true },
    meta: { sources: ['CHILD'] }
});
```

If the source action doesn't match, the action is returned:

```js
import { mapActionTo } from 'brookjs';

const child = {
    type: 'OTHER_CHILD',
    payload: { value: true }
};

const parent = mapActionTo('CHILD', 'PARENT', child);

assert(parent === child);
```

This function is curried, so it can be used to map child events to their parent's actions using preplug:

```js
export default component({
    children: children({
        child: {
          factory: ChildComponent,
          preplug: instance$ => instance$.map(mapActionTo('CHILD', 'PARENT'))
        }
    })
});
```

#### Parameters

* {string} source - Action type to modify.
* {string} dest - Action type to map.
* {Action} action - Action to modify.

#### Returns

* {Action} Modified action if `type` matches, original action if it doesn't.

## observeDelta

`observeDelta` is a Redux middleware for binding a set of delta source streams to a Redux store.

When the middleware gets applied, each source function will be called with two parameters: `actions$` and `state$`. These are `Kefir.Observable`s, with the `actions$` stream emitting every action dispatched through the application, and the `state$` emitting each new state after each action. Each source function should return a Kefir stream, which are combined into a `delta$` stream that emits actions into the Redux store.

Specifically, `state$` is a `Kefir.Property`, which means it retains its current value when it gets subscribed to. Additionally, note that the `state$` will have its value emitted before the `action$`, ensuring that any combination of the stream will have the latest state when the action is emitted.

# Example

An example `source$` stream:

```js
import { Kefir } from 'brookjs';

export default function exampleSourceStream(actions$, state$) {
    const save$ = actions$.filter(action => action.type === 'SAVE_THING');

    return save$.flatMap(action => {
        const request = fetch('/api/url', {
            type: 'POST',
            body: JSON.stringify(action.payload)
        });

        return Kefir.fromPromise(request)
            .map(response => ({
                type: 'THING_SAVED',
                payload: response
            }));
    });
}
```

Applying the middleware with the example:

```js
import { applyMiddleware, createStore } from 'redux';
import { observeDelta } from 'brookjs'
import reducer from './reducer';
import exampleSourceStream from './example'

const store = createStore(reducer, applyMiddleware(observeDelta(exampleSourceStream)));

store.dispatch({ type: 'SAVE_THING', payload: { id: 1, name: 'The Thing to save' } });
```

If you need to get the state on every action, use `sampledBy`:

```js
import { ofType, Kefir } from 'brookjs';

export default function exampleSourceStream(actions$, state$) {
    const save$ = actions$.thru(ofType(SAVE_USER_BUTTON_CLICK));

    return state$.sampledBy(save$).flatMap(state => {
        const request = fetch('/api/user', {
            type: 'POST',
            body: JSON.stringify(state.user)
        });

        return Kefir.fromPromise(request)
            .map(response => ({
                type: 'USER_SAVED',
                payload: response
            }));
    });
}
```

[fsa]: https://github.com/acdlite/flux-standard-action
