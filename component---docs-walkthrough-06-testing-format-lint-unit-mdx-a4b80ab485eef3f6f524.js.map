{"version":3,"sources":["webpack:///../docs/walkthrough/06-testing-format-lint-unit.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---docs-walkthrough-06-testing-format-lint-unit-mdx-a4b80ab485eef3f6f524.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/jamesdigioia/Code/brookjs/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"testing-format-lint--unit\"\n    }}>{`Testing: Format, Lint, & Unit`}</h1>\n    <p>{`The testing tools are the first deep interaction with `}<inlineCode parentName=\"p\">{`brookjs-cli`}</inlineCode>{`. You can run it with `}<inlineCode parentName=\"p\">{`npx beaver`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`yarn beaver`}</inlineCode>{` after it have been installed in your project. It comes with a number of subcommands under the `}<inlineCode parentName=\"p\">{`test`}</inlineCode>{` command. We'll go through them together.`}</p>\n    <h2 {...{\n      \"id\": \"test-check\"\n    }}><inlineCode parentName=\"h2\">{`test check`}</inlineCode></h2>\n    <p>{`The first command is the simplest and checks if the project conforms to prettier's codestyle. Running `}<inlineCode parentName=\"p\">{`beaver test check`}</inlineCode>{` will error if any of them are not in compliance. Running `}<inlineCode parentName=\"p\">{`beaver format`}</inlineCode>{` will format them into compliance.`}</p>\n    <h2 {...{\n      \"id\": \"test-lint\"\n    }}><inlineCode parentName=\"h2\">{`test lint`}</inlineCode></h2>\n    <p>{`Next, we check any issues that can't be fixed automatically. Running `}<inlineCode parentName=\"p\">{`beaver test lint`}</inlineCode>{` checks if the application's code conforms with the `}<inlineCode parentName=\"p\">{`brookjs`}</inlineCode>{` eslint config and error if any of them do not. Any ESLint errors that would be fixable with `}<inlineCode parentName=\"p\">{`--fix`}</inlineCode>{` can be fixed with `}<inlineCode parentName=\"p\">{`beaver format`}</inlineCode>{` but other errors may need manual intervention.`}</p>\n    <h2 {...{\n      \"id\": \"test-unit\"\n    }}><inlineCode parentName=\"h2\">{`test unit`}</inlineCode></h2>\n    <p>{`The bulk of your time testing will be dealing with unit tests. You can run them with `}<inlineCode parentName=\"p\">{`test unit`}</inlineCode>{`. Any files that end with `}<inlineCode parentName=\"p\">{`.{spec,test}.{js,ts}`}</inlineCode>{` are globbed by the runner and executed by `}<a parentName=\"p\" {...{\n        \"href\": \"https://jestjs.io/\"\n      }}>{`Jest`}</a>{` tests.`}</p>\n    <p>{`When bootstrapping an application with `}<inlineCode parentName=\"p\">{`brookjs`}</inlineCode>{`, in addition to configuring Jest, a couple of other addons are also provided:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://storybook.js.org/\"\n        }}>{`Storybook`}</a>{` + `}<a parentName=\"li\" {...{\n          \"href\": \"https://www.npmjs.com/package/@storybook/addon-storyshots\"\n        }}>{`Storyshots`}</a>{` for `}<a parentName=\"li\" {...{\n          \"href\": \"https://storybook.js.org/docs/testing/structural-testing/\"\n        }}>{`structural testing`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/testing-library/jest-dom\"\n        }}><inlineCode parentName=\"a\">{`@testing-library/jest-dom`}</inlineCode></a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/kefirjs/jest-kefir\"\n        }}><inlineCode parentName=\"a\">{`jest-kefir`}</inlineCode></a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/api/brookjs-desalinate/\"\n        }}><inlineCode parentName=\"a\">{`brookjs-desalinate`}</inlineCode></a></li>\n    </ul>\n    <p>{`The above set of tools, combined with Jest, provide everything you need to fully test your application. Let's take a look at the application we built before and see how we'd test it.`}</p>\n    <h3 {...{\n      \"id\": \"low-hanging-fruit-with-storyshots\"\n    }}>{`Low Hanging Fruit with Storyshots`}</h3>\n    <p>{`While we're developing our components, we should also be creating them as stories in Storybook so we can develop each component in isolation. During this process, we should use various stories to put the component into all of the states combos it can be in given the props provided. If you bootstrapped with `}<inlineCode parentName=\"p\">{`brookjs-cli`}</inlineCode>{`, Storyshots will already be configured to take snapshots of all your stories. If not, see the `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.npmjs.com/package/@storybook/addon-storyshots\"\n      }}>{`Storyshots`}</a>{` documentation to set it up.`}</p>\n    <h3 {...{\n      \"id\": \"interaction-testing-with-testing-libraryreact-and-brookjs-desalinate\"\n    }}>{`Interaction Testing with `}<inlineCode parentName=\"h3\">{`@testing-library/react`}</inlineCode>{` and `}<inlineCode parentName=\"h3\">{`brookjs-desalinate`}</inlineCode></h3>\n    <p>{`In addition to testing the various states depending on what went `}<em parentName=\"p\">{`in`}</em>{` to the component, we need to test the various events that come `}<em parentName=\"p\">{`out`}</em>{`. We do this with a Jest matcher provided by `}<inlineCode parentName=\"p\">{`brookjs-desalinate`}</inlineCode>{` called `}<inlineCode parentName=\"p\">{`toEmitFromJunction`}</inlineCode>{`. This matcher uses `}<inlineCode parentName=\"p\">{`@testing-library/react`}</inlineCode>{` under the hood to render the provided element wrapped in a `}<inlineCode parentName=\"p\">{`RootJunction`}</inlineCode>{`, which is then provided to a callback for the user to interact with.`}</p>\n    <p>{`Let's write some tests and see what this looks like.`}</p>\n    <h4 {...{\n      \"id\": \"testing-the-button--input-components\"\n    }}>{`Testing the `}<inlineCode parentName=\"h4\">{`Button`}</inlineCode>{` & `}<inlineCode parentName=\"h4\">{`Input`}</inlineCode>{` Components`}</h4>\n    <p>{`For the `}<inlineCode parentName=\"p\">{`Button`}</inlineCode>{` component, we have to ensure that it emits the expected action when we click it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Button.spec.js\ndescribe('Button', () => {\n  it('should emit a click event', () => {\n    expect(<Button />).toEmitFromJunction(\n      [KTU.value(click())],\n      ({ container }) => {\n        fireEvent.click(container.querySelector('button'));\n      }\n    );\n  });\n});\n`}</code></pre>\n    <p>{`That's it! Between Storyshots and this simple test, te've fully tested the behavior of the component.`}</p>\n    <p>{`We can do the same thing with the `}<inlineCode parentName=\"p\">{`Input`}</inlineCode>{` component.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Input.spec.js\ndescribe('Input', () => {\n  it('should emit a change event', () => {\n    expect(<Input />).toEmitFromJunction(\n      [KTU.value(change('new value'))],\n      ({ container }) => {\n        fireEvent.change(container.querySelector('input'), {\n          target: { value: 'new value' }\n        });\n      }\n    );\n  });\n});\n`}</code></pre>\n    <p>{`And again, we're done! This are simple tests for simple components, but demonstrate how testing with `}<inlineCode parentName=\"p\">{`brookjs`}</inlineCode>{` components is about testing the component's input & output.`}</p>\n    <h4 {...{\n      \"id\": \"testing-the-addtodo-component\"\n    }}>{`Testing the `}<inlineCode parentName=\"h4\">{`AddTodo`}</inlineCode>{` component`}</h4>\n    <p>{`The `}<inlineCode parentName=\"p\">{`AddTodo`}</inlineCode>{` component is slightly more complicated than the other two, with its own state to manage and wrapper around the `}<inlineCode parentName=\"p\">{`Input`}</inlineCode>{` & `}<inlineCode parentName=\"p\">{`Button`}</inlineCode>{` components' central Observable. Your first inclination might be to test the `}<inlineCode parentName=\"p\">{`reducer`}</inlineCode>{` in isolation, but we can test it in context by asserting against the render results of that state change.`}</p>\n    <p>{`Let's take a look at how we could do that.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`describe('AddTodo', () => {\n  it('should emit ADD_TODO event on submit', () => {\n    expect(<AddTodo />).toEmitFromJunction(\n      [addTodo('do a thing')],\n      ({ container }) => {\n        const input = container.querySelector('input');\n        const button = container.querySelector('button');\n\n        fireEvent.change(input, { target: { value: 'do a thing' } });\n\n        expect(input).toHaveValue('do a thing');\n\n        fireEvent.click(button);\n\n        expect(input).toHaveValue('');\n      }\n    );\n  });\n});\n`}</code></pre>\n    <p>{`Here we reproduce the steps the user would go through to add a new todo: type it into the input, and click the submit button. After each event, we verify the state of the DOM, ensuring that the state is managed correctly. After this function has run, `}<inlineCode parentName=\"p\">{`toEmitFromJunction`}</inlineCode>{` asserts that the only the single event has been emitted.`}</p>\n    <h5 {...{\n      \"id\": \"a-note-on-coverage\"\n    }}>{`A Note on Coverage`}</h5>\n    <p>{`As you may have noticed, the `}<inlineCode parentName=\"p\">{`AddTodo`}</inlineCode>{` tests overlap with the `}<inlineCode parentName=\"p\">{`Input`}</inlineCode>{` & `}<inlineCode parentName=\"p\">{`Button`}</inlineCode>{` tests, as they both end up exercising the underlying elements. It's up to you whether you feel the need to test both. If something like `}<inlineCode parentName=\"p\">{`AddTodo`}</inlineCode>{` is foundational, then you can test the other two through it, but you don't want to end up deleting the parent component and be left with no tests on the underlying components, which wouldn't happen if you tested them directly.`}</p>\n    <h3 {...{\n      \"id\": \"testing-a-command-returning-reducer\"\n    }}>{`Testing a Command-Returning Reducer`}</h3>\n    <p>{`Reducers are straightfoward to test because they're pure functions that return new values. Testing them is a matter of passing in the current state and asserting against the return value.`}</p>\n    <p>{`Let's take a look.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// reducer.spec.js\ndescribe('reducer', () => {\n  it('should handle ADD_TODO', () => {\n    expect(reducer([], addTodo('New todo'))).toEqual(\n      loop(\n        [{ name: 'New todo', completed: false }],\n        saveTodoRequest({\n          name: 'New todo',\n          completed: false\n        })\n      )\n    );\n  });\n});\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"testing-deltas\"\n    }}>{`Testing Deltas`}</h3>\n    <p>{`Testing deltas is a lot less straightfoward than the previous test flows. Fortunately, `}<inlineCode parentName=\"p\">{`brookjs-desalinate`}</inlineCode>{` provides some helpers to make testing them easier. Let's try out a new expectation, `}<inlineCode parentName=\"p\">{`toEmitFromDelta`}</inlineCode>{`, to test our `}<inlineCode parentName=\"p\">{`rootDelta`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// delta.spec.js\njest.mock('../ajax', () => { ... })\n\ndescribe('rootDelta', () => {\n  it('should emit success when making a successful API request', () => {\n    const todo = { name: 'New Todo', completed: false };\n\n    expect(rootDelta).toEmitFromDelta(\n      [KTU.value(saveTodoSucceeded(todo))],\n      send => {\n        send(saveTodoRequest(todo), { todos: [todo] });\n      }\n    );\n  });\n});\n`}</code></pre>\n    <p>{`This test is slightly more complicated, because how you handle side effects will determine how you write these tests. One option is to segregate all of the side-effect-producing functions to a separate module (e.g. `}<inlineCode parentName=\"p\">{`api`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`localStorage`}</inlineCode>{`), then use Jest's `}<a parentName=\"p\" {...{\n        \"href\": \"https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options\"\n      }}>{`module mocking`}</a>{` capabilities to replace the functions with mocks. Using that, you can control the API calls and their responses.`}</p>\n    <p>{`Alternatively, you can use a module like `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/axios/axios\"\n      }}><inlineCode parentName=\"a\">{`axios`}</inlineCode></a>{` and `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/ctimmerm/axios-mock-adapter\"\n      }}><inlineCode parentName=\"a\">{`axios-mock-adapter`}</inlineCode></a>{` to control the API calls and their responses, or use `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\"\n      }}><inlineCode parentName=\"a\">{`fetch`}</inlineCode></a>{` alongside `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.npmjs.com/package/jest-fetch-mock\"\n      }}><inlineCode parentName=\"a\">{`jest-fetch-mock`}</inlineCode></a>{` to control those API responses. Whatever path you choose, the idea is to mock at the side-effect boundary and test the delta emits the actions expected. Since any external source of data to the application could potentially emit errors, we should wrap them in deltas and thus control the data emitted into the reducer.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}