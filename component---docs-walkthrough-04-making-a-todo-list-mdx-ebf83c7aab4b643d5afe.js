(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{nKjU:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return r})),n.d(t,"default",(function(){return p}));n("7+lW"),n("aHyW"),n("2Vap"),n("y7Hy"),n("LNPl"),n("owTU");var o=n("V0Ug"),a=n("sN0p");n("xH0s");function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}).apply(this,arguments)}var r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!r.hasOwnProperty("__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/walkthrough/04-making-a-todo-list.mdx"}});var c={_frontmatter:r},l=a.a;function p(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,["components"]);return Object(o.b)(l,i({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"making-a-todo-list"},"Making a Todo List"),Object(o.b)("p",null,"Now that we know how to combine together ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs")," components into bigger components, let's start building our todo list. At this point, we're going to add some application level state, which we'll keep in Redux."),Object(o.b)("h2",{id:"create-addtodo-component"},"Create ",Object(o.b)("inlineCode",{parentName:"h2"},"AddTodo")," Component"),Object(o.b)("p",null,"We're going to start with the ",Object(o.b)("inlineCode",{parentName:"p"},"AddTodo")," component, which is a modified ",Object(o.b)("inlineCode",{parentName:"p"},"Submit")," component. It should look familiar."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// AddTodo.js\nimport { createAction } from 'redux-actions';\nimport { RootJunction, ofType } from 'brookjs';\nimport { changeAction, clickAction, addTodoAction } from '../actions';\nimport Input from './Input';\nimport Button from './Button';\n\nconst defaultState = {\n  value: ''\n};\n\nconst reducer = handleActions(\n  {\n    [changeAction]: (state, action) => ({\n      ...state,\n      value: action.payload.value\n    }),\n    [clickAction]: state => ({\n      ...state,\n      // Clear value on submission\n      value: ''\n    })\n  },\n  defaultState\n);\n\nconst AddTodo = () => {\n  const { root$, state } = useDelta(reducer, defaultState);\n\n  return (\n    <RootJunction root$={root$}>\n      <div className=\"add-todo\">\n        <Input label=\"Todo: \" name=\"input\" value={state.value} />\n        <Button>Add Todo</Button>\n      </div>\n    </RootJunction>\n  );\n};\n\nconst events = {};\n\nconst combine = all$ => {\n  const change$ = all$.thru(ofType(changeAction));\n  const click$ = all$.thru(ofType(clickAction));\n\n  return change$\n    .filter(action => action.payload.value !== '')\n    .sampledBy(click$)\n    .map(action => addTodoAction(action.payload.value));\n};\n\nexport default toJunction(events, combine)(Submit);\n")),Object(o.b)("p",null,"The differences here are the label and the emitted action (and obviously the component name)."),Object(o.b)("h2",{id:"create-app-component"},"Create ",Object(o.b)("inlineCode",{parentName:"h2"},"App")," Component"),Object(o.b)("p",null,"Now that we have a component to add new todos, we need to create the ",Object(o.b)("inlineCode",{parentName:"p"},"App")," component. This combines the ",Object(o.b)("inlineCode",{parentName:"p"},"AddTodo")," with the list of created todos."),Object(o.b)("p",null,"In your application, you'll have two choices at this point: if you want to avoid Redux, ",Object(o.b)("inlineCode",{parentName:"p"},"useDelta")," works perfectly well at this point in the application, managing your root state. Alternatively, you can do it in Redux and manage app-level state outside of your UI tree. For demonstration purposes, we're going to wire it up to Redux, which means the App component won't have any state."),Object(o.b)("p",null,"Let's see what that looks like:"),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// components/App.js\nconst App = ({ todos }) => {\n  return (\n    <main>\n      <AddTodo />\n      <ul>\n        {todos.map((todo, i) => (\n          <li key={i}>{todo.name}</li>\n        ))}\n      </ul>\n    </main>\n  );\n};\n")),Object(o.b)("p",null,"Note that even though this emits events, we don't have to wire anything up here."),Object(o.b)("h2",{id:"wiring-the-app-to-redux"},"Wiring the ",Object(o.b)("inlineCode",{parentName:"h2"},"App")," to Redux"),Object(o.b)("p",null,"This entry point is generated by default for you with the CLI, but let's take a look at a simplified version. This is the application entry point, where it connects everything together and starts the application. Not everything we're importing we've seen yet, but we'll look at all of it by the end of this walkthrough."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// index.js\nimport React from 'react';\nimport { createStore } from 'brookjs';\nimport { RootJunction } from 'brookjs-silt';\nimport ReactDOM from 'react-dom';\nimport { init } from './actions';\nimport { App } from './components';\nimport { rootDelta } from './deltas';\nimport { reducer, mapStateToProps } from './state';\n\nconst store = createStore(reducer, initialState, rootDelta);\nconst render = () => {\n  ReactDOM.render(\n    <RootJunction root$={root$ => root$.observe(store.dispatch)}>\n      <App {...mapStateToProps(store.getState())} />\n    </RootJunction>,\n    document.getElementById('root')\n  );\n};\n\nstore.subscribe(render);\nstore.dispatch(init());\n")),Object(o.b)("p",null,"We use a wrapped version of ",Object(o.b)("inlineCode",{parentName:"p"},"createStore")," provided by ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs")," to create our Redux store. This enables a few things:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"A correctly-typed Eddy reducer"),Object(o.b)("li",{parentName:"ol"},"A single ",Object(o.b)("inlineCode",{parentName:"li"},"rootDelta")),Object(o.b)("li",{parentName:"ol"},"Wiring into redux devtools")),Object(o.b)("p",null,"We create a render function that is called every time the store changes. Instead of pulling in ",Object(o.b)("inlineCode",{parentName:"p"},"react-redux"),", we subscribe to the store directly and map the state to props for the ",Object(o.b)("inlineCode",{parentName:"p"},"App")," component. We'll then drill down the props to the child components as needed. This keeps the initial app light and allows you to bring in ",Object(o.b)("inlineCode",{parentName:"p"},"react-redux")," when you need."),Object(o.b)("p",null,"We then dispatch an ",Object(o.b)("inlineCode",{parentName:"p"},"init")," event to kick off the application. This is useful for the ",Object(o.b)("inlineCode",{parentName:"p"},"rootDelta")," if you want them to emit events on startup, as they can't emit events synchronously on bootstrapping."),Object(o.b)("h2",{id:"manage-redux-state"},"Manage Redux State"),Object(o.b)("p",null,"Now that we've got the application wired to Redux, we need to write the functions that manage our Redux state. In the above, that's the ",Object(o.b)("inlineCode",{parentName:"p"},"state.js")," module, which contains our root selector function as well as our reducer."),Object(o.b)("p",null,"Let's take a look."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// state/index.js\nimport { handleActions } from 'redux-actions';\nimport { combineReducers } from 'brookjs';\nimport { addTodoAction } from '../actions';\n\nconst todosReducer = handleActions(\n  {\n    [addTodoAction]: (state, action) => [\n      ...state,\n      { name: action.payload.name, completed: false }\n    ]\n  },\n  []\n);\n\nexport const reducer = combineReducers({\n  todos: todosReducer\n});\n\nexport const mapStateToProps = state => ({\n  todo: state.todos\n});\n")),Object(o.b)("p",null,"We again create a reducer with ",Object(o.b)("inlineCode",{parentName:"p"},"handleActions")," for the ",Object(o.b)("inlineCode",{parentName:"p"},"todoReducer"),", and we import ",Object(o.b)("inlineCode",{parentName:"p"},"combineReducers")," from ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs")," instead of Redux. This will provide some extra features we'll learn about later. We also create a ",Object(o.b)("inlineCode",{parentName:"p"},"mapStateToProps"),", which plucks off the ",Object(o.b)("inlineCode",{parentName:"p"},"todos")," we need for our ",Object(o.b)("inlineCode",{parentName:"p"},"App"),". This should all be pretty familiar if you've used Redux before."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"TODO: Add Codesandbox link.")))}p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/walkthrough/04-making-a-todo-list.mdx"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-walkthrough-04-making-a-todo-list-mdx-ebf83c7aab4b643d5afe.js.map