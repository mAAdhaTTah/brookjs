(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{"/sq2":function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return s})),a.d(t,"default",(function(){return o}));a("7+lW"),a("aHyW"),a("2Vap"),a("y7Hy"),a("LNPl"),a("owTU");var r=a("V0Ug"),n=a("sN0p");a("xH0s");function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e}).apply(this,arguments)}var s={};void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/walkthrough/02-observables.mdx"}});var b={_frontmatter:s},l=n.a;function o(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,["components"]);return Object(r.b)(l,i({},b,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"what-are-observables"},"What are Observables?"),Object(r.b)("p",null,"Before we start getting into ",Object(r.b)("inlineCode",{parentName:"p"},"brookjs"),", let's take a short detour to talk about Observables. For ",Object(r.b)("inlineCode",{parentName:"p"},"brookjs"),", we'll be using ",Object(r.b)("a",i({parentName:"p"},{href:"https://kefirjs.github.io/kefir/"}),"Kefirjs"),", which has a few properties that make it a good choice over RxJS:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Hot observables by default"),Object(r.b)("li",{parentName:"ol"},"Comparable performance"),Object(r.b)("li",{parentName:"ol"},"Thrown errors crash"),Object(r.b)("li",{parentName:"ol"},"Smaller API surface")),Object(r.b)("p",null,"If you're new to Observables, the 4th bullet is probably the most important. This makes Kefir easier to learn & use, as there are fewer methods to wrap your head around."),Object(r.b)("h2",{id:"array-over-time"},"Array Over Time"),Object(r.b)("p",null,"The best way to describe Observables is as an array whose values arrive over time. Instead of them being available in the array at the time you subscribe to the Observable, those values are pushed into the Observable by the data source."),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{className:"language-js"}),"const input$ = Kefir.fromEvents(document.querySelector('input'), 'input');\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note: Suffixing the variable name with ",Object(r.b)("inlineCode",{parentName:"em"},"$")," for Observables is a common convention but not a requirement.")),Object(r.b)("p",null,"Every time the ",Object(r.b)("inlineCode",{parentName:"p"},"input")," event fires, the ",Object(r.b)("inlineCode",{parentName:"p"},"Event")," object is pushed into the stream. We can now manipulate the stream similar to an array."),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{className:"language-js"}),"// Map the event to its current value\nconst value$ = input$.map(e => e.target.value);\n")),Object(r.b)("p",null,"Now, every time the value changes, it's pushed as a new value into the stream, and ",Object(r.b)("inlineCode",{parentName:"p"},"value$")," always has the latest value from the input. We can model this with a Marble Diagram:"),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{}),"|a---b----c----d---e-f-gh----i|\n")),Object(r.b)("p",null,"Letters are used to represent the different values emitted by the stream, with the ",Object(r.b)("inlineCode",{parentName:"p"},"-")," representing the passage of a set amount of time."),Object(r.b)("h2",{id:"combining-observables"},"Combining Observables"),Object(r.b)("p",null,"This may not seem that interesting, but what if we only wanted to get the value of the input whenever a button is clicked?"),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{className:"language-js"}),"const click$ = Kefir.fromEvents(document.querySelector('button'), 'click');\nconst submit$ = input$.sampledBy(click$);\n")),Object(r.b)("p",null,"In a few lines of code, we combine the two Observables so that the relationship between them is explicit. We can model this stream with this marble diagram:"),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{}),"input$  |a---b----c----d---e-f-gh----i|\nclick$  |-----------.-------------.---|\nsubmit$ |-----------c-------------h---|\n")),Object(r.b)("p",null,"Every time the button is clicked, the last value from ",Object(r.b)("inlineCode",{parentName:"p"},"input$")," Observable is emitted from the ",Object(r.b)("inlineCode",{parentName:"p"},"submit$")," Observable."),Object(r.b)("h2",{id:"handling-side-effects"},"Handling Side Effects"),Object(r.b)("p",null,"Now that we've got the latest value at the point it's been submitted, we need to run the search against the API. We can plug Observables into other Observables with ",Object(r.b)("inlineCode",{parentName:"p"},"flatMap"),":"),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{className:"language-js"}),"const results$ = submit$.flatMap(term =>\n  ajax$(`/api/search?s=${term}`)\n    .flatMap(res => res.json())\n    .map(body => body.results)\n);\n")),Object(r.b)("p",null,"There's one issue with this though: If ",Object(r.b)("inlineCode",{parentName:"p"},"term")," is an empty string, it will still hit the API, which will result in an error. To fix this, we can filter out any empty values:"),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{className:"language-js"}),"const results$ = submit$\n  .filter(term => term !== '')\n  .flatMap(term =>\n    ajax$(`/api/search?s=${term}`)\n      .flatMap(res => res.json())\n      .map(body => body.results)\n  );\n")),Object(r.b)("p",null,"Assuming ",Object(r.b)("inlineCode",{parentName:"p"},"ajax$")," is an Observable-based AJAX library, this searches the API with the current term entered in the input field. We can use the output of this stream to render the search results and output it to the DOM."),Object(r.b)("pre",null,Object(r.b)("code",i({parentName:"pre"},{className:"language-js"}),"const resultsHTML$ = results$\n  .map(results => results.map(result => `<li>${result.name}</li>`))\n  .flatMapErrors(error => Kefir.constant(`<li>Error: ${error.message}</li>`));\n\nresultsHTML$.observe(html => {\n  resultsUl.innerHTML = html;\n});\n")),Object(r.b)("p",null,"In ",Object(r.b)("inlineCode",{parentName:"p"},"brookjs"),", React is responsible for managing the DOM, and we put our side effects in a delta, which we'll learn about later, but it's this relationship between things happening in various parts of the system that Observables are able to express. We take advantage of this in ",Object(r.b)("inlineCode",{parentName:"p"},"brookjs"),"' architecture."),Object(r.b)("h2",{id:"further-resources"},"Further Resources"),Object(r.b)("p",null,"This is a pretty quick introduction what Observables are and their benefits. If you want to explore this in more depth, below are some online resources that go into this in more depth."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://kefirjs.github.io/kefir/"}),"Kefir docs")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"}),"The introduction to Reactive Programming you've been missing\n"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://egghead.io/series/introduction-to-reactive-programming"}),"Video series")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"http://reactivex.io/learnrx/"}),"ReactiveX")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://www.youtube.com/watch?v=FAZJsxcykPs"}),"Video: Netflix JavaScript Talks - Async JavaScript with Reactive Extensions"))),Object(r.b)("p",null,"If you're interested in expanding this list or"))}o&&o===Object(o)&&Object.isExtensible(o)&&!o.hasOwnProperty("__filemeta")&&Object.defineProperty(o,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/walkthrough/02-observables.mdx"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-walkthrough-02-observables-mdx-3efe9267e75294d65de8.js.map