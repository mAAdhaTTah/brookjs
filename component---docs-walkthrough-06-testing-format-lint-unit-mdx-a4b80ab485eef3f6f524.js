(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{Me0D:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return r})),n.d(t,"default",(function(){return l}));n("7+lW"),n("aHyW"),n("2Vap"),n("y7Hy"),n("LNPl"),n("owTU");var o=n("V0Ug"),a=n("sN0p");n("xH0s");function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}).apply(this,arguments)}var r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!r.hasOwnProperty("__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/walkthrough/06-testing-format-lint-unit.mdx"}});var s={_frontmatter:r},c=a.a;function l(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,["components"]);return Object(o.b)(c,i({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"testing-format-lint--unit"},"Testing: Format, Lint, & Unit"),Object(o.b)("p",null,"The testing tools are the first deep interaction with ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs-cli"),". You can run it with ",Object(o.b)("inlineCode",{parentName:"p"},"npx beaver")," or ",Object(o.b)("inlineCode",{parentName:"p"},"yarn beaver")," after it have been installed in your project. It comes with a number of subcommands under the ",Object(o.b)("inlineCode",{parentName:"p"},"test")," command. We'll go through them together."),Object(o.b)("h2",{id:"test-check"},Object(o.b)("inlineCode",{parentName:"h2"},"test check")),Object(o.b)("p",null,"The first command is the simplest and checks if the project conforms to prettier's codestyle. Running ",Object(o.b)("inlineCode",{parentName:"p"},"beaver test check")," will error if any of them are not in compliance. Running ",Object(o.b)("inlineCode",{parentName:"p"},"beaver format")," will format them into compliance."),Object(o.b)("h2",{id:"test-lint"},Object(o.b)("inlineCode",{parentName:"h2"},"test lint")),Object(o.b)("p",null,"Next, we check any issues that can't be fixed automatically. Running ",Object(o.b)("inlineCode",{parentName:"p"},"beaver test lint")," checks if the application's code conforms with the ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs")," eslint config and error if any of them do not. Any ESLint errors that would be fixable with ",Object(o.b)("inlineCode",{parentName:"p"},"--fix")," can be fixed with ",Object(o.b)("inlineCode",{parentName:"p"},"beaver format")," but other errors may need manual intervention."),Object(o.b)("h2",{id:"test-unit"},Object(o.b)("inlineCode",{parentName:"h2"},"test unit")),Object(o.b)("p",null,"The bulk of your time testing will be dealing with unit tests. You can run them with ",Object(o.b)("inlineCode",{parentName:"p"},"test unit"),". Any files that end with ",Object(o.b)("inlineCode",{parentName:"p"},".{spec,test}.{js,ts}")," are globbed by the runner and executed by ",Object(o.b)("a",i({parentName:"p"},{href:"https://jestjs.io/"}),"Jest")," tests."),Object(o.b)("p",null,"When bootstrapping an application with ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs"),", in addition to configuring Jest, a couple of other addons are also provided:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",i({parentName:"li"},{href:"https://storybook.js.org/"}),"Storybook")," + ",Object(o.b)("a",i({parentName:"li"},{href:"https://www.npmjs.com/package/@storybook/addon-storyshots"}),"Storyshots")," for ",Object(o.b)("a",i({parentName:"li"},{href:"https://storybook.js.org/docs/testing/structural-testing/"}),"structural testing")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",i({parentName:"li"},{href:"https://github.com/testing-library/jest-dom"}),Object(o.b)("inlineCode",{parentName:"a"},"@testing-library/jest-dom"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",i({parentName:"li"},{href:"https://github.com/kefirjs/jest-kefir"}),Object(o.b)("inlineCode",{parentName:"a"},"jest-kefir"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",i({parentName:"li"},{href:"/api/brookjs-desalinate/"}),Object(o.b)("inlineCode",{parentName:"a"},"brookjs-desalinate")))),Object(o.b)("p",null,"The above set of tools, combined with Jest, provide everything you need to fully test your application. Let's take a look at the application we built before and see how we'd test it."),Object(o.b)("h3",{id:"low-hanging-fruit-with-storyshots"},"Low Hanging Fruit with Storyshots"),Object(o.b)("p",null,"While we're developing our components, we should also be creating them as stories in Storybook so we can develop each component in isolation. During this process, we should use various stories to put the component into all of the states combos it can be in given the props provided. If you bootstrapped with ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs-cli"),", Storyshots will already be configured to take snapshots of all your stories. If not, see the ",Object(o.b)("a",i({parentName:"p"},{href:"https://www.npmjs.com/package/@storybook/addon-storyshots"}),"Storyshots")," documentation to set it up."),Object(o.b)("h3",{id:"interaction-testing-with-testing-libraryreact-and-brookjs-desalinate"},"Interaction Testing with ",Object(o.b)("inlineCode",{parentName:"h3"},"@testing-library/react")," and ",Object(o.b)("inlineCode",{parentName:"h3"},"brookjs-desalinate")),Object(o.b)("p",null,"In addition to testing the various states depending on what went ",Object(o.b)("em",{parentName:"p"},"in")," to the component, we need to test the various events that come ",Object(o.b)("em",{parentName:"p"},"out"),". We do this with a Jest matcher provided by ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs-desalinate")," called ",Object(o.b)("inlineCode",{parentName:"p"},"toEmitFromJunction"),". This matcher uses ",Object(o.b)("inlineCode",{parentName:"p"},"@testing-library/react")," under the hood to render the provided element wrapped in a ",Object(o.b)("inlineCode",{parentName:"p"},"RootJunction"),", which is then provided to a callback for the user to interact with."),Object(o.b)("p",null,"Let's write some tests and see what this looks like."),Object(o.b)("h4",{id:"testing-the-button--input-components"},"Testing the ",Object(o.b)("inlineCode",{parentName:"h4"},"Button")," & ",Object(o.b)("inlineCode",{parentName:"h4"},"Input")," Components"),Object(o.b)("p",null,"For the ",Object(o.b)("inlineCode",{parentName:"p"},"Button")," component, we have to ensure that it emits the expected action when we click it."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// Button.spec.js\ndescribe('Button', () => {\n  it('should emit a click event', () => {\n    expect(<Button />).toEmitFromJunction(\n      [KTU.value(click())],\n      ({ container }) => {\n        fireEvent.click(container.querySelector('button'));\n      }\n    );\n  });\n});\n")),Object(o.b)("p",null,"That's it! Between Storyshots and this simple test, te've fully tested the behavior of the component."),Object(o.b)("p",null,"We can do the same thing with the ",Object(o.b)("inlineCode",{parentName:"p"},"Input")," component."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// Input.spec.js\ndescribe('Input', () => {\n  it('should emit a change event', () => {\n    expect(<Input />).toEmitFromJunction(\n      [KTU.value(change('new value'))],\n      ({ container }) => {\n        fireEvent.change(container.querySelector('input'), {\n          target: { value: 'new value' }\n        });\n      }\n    );\n  });\n});\n")),Object(o.b)("p",null,"And again, we're done! This are simple tests for simple components, but demonstrate how testing with ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs")," components is about testing the component's input & output."),Object(o.b)("h4",{id:"testing-the-addtodo-component"},"Testing the ",Object(o.b)("inlineCode",{parentName:"h4"},"AddTodo")," component"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"AddTodo")," component is slightly more complicated than the other two, with its own state to manage and wrapper around the ",Object(o.b)("inlineCode",{parentName:"p"},"Input")," & ",Object(o.b)("inlineCode",{parentName:"p"},"Button")," components' central Observable. Your first inclination might be to test the ",Object(o.b)("inlineCode",{parentName:"p"},"reducer")," in isolation, but we can test it in context by asserting against the render results of that state change."),Object(o.b)("p",null,"Let's take a look at how we could do that."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"describe('AddTodo', () => {\n  it('should emit ADD_TODO event on submit', () => {\n    expect(<AddTodo />).toEmitFromJunction(\n      [addTodo('do a thing')],\n      ({ container }) => {\n        const input = container.querySelector('input');\n        const button = container.querySelector('button');\n\n        fireEvent.change(input, { target: { value: 'do a thing' } });\n\n        expect(input).toHaveValue('do a thing');\n\n        fireEvent.click(button);\n\n        expect(input).toHaveValue('');\n      }\n    );\n  });\n});\n")),Object(o.b)("p",null,"Here we reproduce the steps the user would go through to add a new todo: type it into the input, and click the submit button. After each event, we verify the state of the DOM, ensuring that the state is managed correctly. After this function has run, ",Object(o.b)("inlineCode",{parentName:"p"},"toEmitFromJunction")," asserts that the only the single event has been emitted."),Object(o.b)("h5",{id:"a-note-on-coverage"},"A Note on Coverage"),Object(o.b)("p",null,"As you may have noticed, the ",Object(o.b)("inlineCode",{parentName:"p"},"AddTodo")," tests overlap with the ",Object(o.b)("inlineCode",{parentName:"p"},"Input")," & ",Object(o.b)("inlineCode",{parentName:"p"},"Button")," tests, as they both end up exercising the underlying elements. It's up to you whether you feel the need to test both. If something like ",Object(o.b)("inlineCode",{parentName:"p"},"AddTodo")," is foundational, then you can test the other two through it, but you don't want to end up deleting the parent component and be left with no tests on the underlying components, which wouldn't happen if you tested them directly."),Object(o.b)("h3",{id:"testing-a-command-returning-reducer"},"Testing a Command-Returning Reducer"),Object(o.b)("p",null,"Reducers are straightfoward to test because they're pure functions that return new values. Testing them is a matter of passing in the current state and asserting against the return value."),Object(o.b)("p",null,"Let's take a look."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// reducer.spec.js\ndescribe('reducer', () => {\n  it('should handle ADD_TODO', () => {\n    expect(reducer([], addTodo('New todo'))).toEqual(\n      loop(\n        [{ name: 'New todo', completed: false }],\n        saveTodoRequest({\n          name: 'New todo',\n          completed: false\n        })\n      )\n    );\n  });\n});\n")),Object(o.b)("h3",{id:"testing-deltas"},"Testing Deltas"),Object(o.b)("p",null,"Testing deltas is a lot less straightfoward than the previous test flows. Fortunately, ",Object(o.b)("inlineCode",{parentName:"p"},"brookjs-desalinate")," provides some helpers to make testing them easier. Let's try out a new expectation, ",Object(o.b)("inlineCode",{parentName:"p"},"toEmitFromDelta"),", to test our ",Object(o.b)("inlineCode",{parentName:"p"},"rootDelta"),"."),Object(o.b)("pre",null,Object(o.b)("code",i({parentName:"pre"},{className:"language-js"}),"// delta.spec.js\njest.mock('../ajax', () => { ... })\n\ndescribe('rootDelta', () => {\n  it('should emit success when making a successful API request', () => {\n    const todo = { name: 'New Todo', completed: false };\n\n    expect(rootDelta).toEmitFromDelta(\n      [KTU.value(saveTodoSucceeded(todo))],\n      send => {\n        send(saveTodoRequest(todo), { todos: [todo] });\n      }\n    );\n  });\n});\n")),Object(o.b)("p",null,"This test is slightly more complicated, because how you handle side effects will determine how you write these tests. One option is to segregate all of the side-effect-producing functions to a separate module (e.g. ",Object(o.b)("inlineCode",{parentName:"p"},"api")," or ",Object(o.b)("inlineCode",{parentName:"p"},"localStorage"),"), then use Jest's ",Object(o.b)("a",i({parentName:"p"},{href:"https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options"}),"module mocking")," capabilities to replace the functions with mocks. Using that, you can control the API calls and their responses."),Object(o.b)("p",null,"Alternatively, you can use a module like ",Object(o.b)("a",i({parentName:"p"},{href:"https://github.com/axios/axios"}),Object(o.b)("inlineCode",{parentName:"a"},"axios"))," and ",Object(o.b)("a",i({parentName:"p"},{href:"https://github.com/ctimmerm/axios-mock-adapter"}),Object(o.b)("inlineCode",{parentName:"a"},"axios-mock-adapter"))," to control the API calls and their responses, or use ",Object(o.b)("a",i({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"}),Object(o.b)("inlineCode",{parentName:"a"},"fetch"))," alongside ",Object(o.b)("a",i({parentName:"p"},{href:"https://www.npmjs.com/package/jest-fetch-mock"}),Object(o.b)("inlineCode",{parentName:"a"},"jest-fetch-mock"))," to control those API responses. Whatever path you choose, the idea is to mock at the side-effect boundary and test the delta emits the actions expected. Since any external source of data to the application could potentially emit errors, we should wrap them in deltas and thus control the data emitted into the reducer."))}l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/walkthrough/06-testing-format-lint-unit.mdx"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-walkthrough-06-testing-format-lint-unit-mdx-a4b80ab485eef3f6f524.js.map