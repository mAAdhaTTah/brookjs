---
name: Home
route: /
---

# brookjs

## Download

- [Development Version][dev]
- [Production Version][prod]

## Why brookjs?

`brookjs` combines React/Redux with reactive programming tools to enable well-structured, testable applications that are performant by default.

### Well-Structured

`brookjs` enables you to express changes in your components as streams. Props can be provided to a component as a stream and mapped to the specific changes in the DOM they're supposed to make (Input). DOM events can be mapped to the specific events they're supposed to dispatch into Redux (Output). Thus, components become solely an expression of I/O, maintaining no internal state by default.

The entire application is modeled this way, which makes where particular pieces of logic belong obvious, as it's intentionally designed to be difficult to put those pieces of logic elsewhere. Using observables to express this logic makes it easy to handle asynchronous, event-driven JavaScript.

With side effects pushed into a corner, all application logic is defined in the Redux store. Reducers can express the state of the application as a result of this action as well as what happens _next_, keeping side effects decoupled from one another.

### Testable

With your components acting as I/O, testing them requires passing in state and ensuring the correct DOM is emitted, and triggering DOM events against them and ensuring the correct events are emitted. All side effects in your application can be tested like this, ensuring the communication channels out of the application function as expected.

Your application logic is expressed in your reducers, which are all pure functions. This makes them easy to test, checking that a state & action combination produces the expected new state & next action.

Integration testing can be handled by replacing I/O with a matching mock I/O, controlling what events are emitted in response to what commands. You can drive your application at every level, from small unit tests handling detailed logic, integration tests ensuring a particular piece of the application runs as expected, all the way up to full end-to-end tests in the browser.

### Automatically Performant

With DOM changes expressed as observables, the resulting change would actually trigger unless the observable emits a new value. This allows changes to be controlled at the very edge of the system and filter out any values that match the previous values, avoiding rerenders. Combined with memoized selectors, a basic strict equality check becomes all that's necessary.

In loops, `brookjs` requires a structure designed for performance, enabling React to rearrange components with shared keys while the children receive the same stream each time. This keeps children from needing to rebind to new streams on every render and avoids costly loops to search for values.

## Influences

- [React][react]/[Redux][redux]
- [Cycle.js][cyclejs]
- [Karet][karet]
- [redux-observable][r-obs]
- [elm][elm]
- [Ports & Adapters Architecture][paa]
- [Actor Model][actor]
- [Event sourcing][event-srcing]
- [CQRS][cqrs]

## Community

- [Gitter][gitter]

[dev]: dist/brook.js
[prod]: dist/brook.min.js
[react]: https://reactjs.org/
[redux]: https://redux.js.org/
[cyclejs]: https://cycle.js.org/
[karet]: https://github.com/calmm-js/karet/
[r-obs]: https://redux-observable.js.org/
[elm]: http://elm-lang.org/
[paa]: http://alistair.cockburn.us/Hexagonal+architecture
[actor]: http://berb.github.io/diploma-thesis/original/054_actors.html
[event-srcing]: https://martinfowler.com/eaaDev/EventSourcing.html
[cqrs]: https://martinfowler.com/bliki/CQRS.html
[gitter]: https://gitter.im/brookjs/Lobby
